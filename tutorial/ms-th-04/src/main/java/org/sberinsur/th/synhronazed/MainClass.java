package org.sberinsur.th.synhronazed;

import java.util.ArrayList;
import java.util.List;

public class MainClass {

    /**
     * Поле, которое нужно залочить, следует делать финальным.
     * Иначе, при подмене ссылки, синхронизированный код может выполняться параллельно в разных потоках.
     */
    private final List<Integer> list = new ArrayList<>();

    /**
     * Метод с синхронизированным блоком кода внутри. Блочится по полю list.
     * (Может быть внутренней переменной метода).
     * Intrinsic lock пока выполняется синхронизированный блок кода, остальные потоки
     * не могут выполнять синхронизированные блоки кода по полю list.
     */
    public void method5() {
        //Не синхронизированная логика метода по переменной
        synchronized (list) {
            list.add(1);
            //Синхронизированная логика метода
        }
    }

    /**
     * Синхронизированный метод. Блочится по экземпляру вызывающего класса.
     * Intrinsic lock пока выполняется метод, остальные синхронизированные методы не могут менять переменные экземпляра.
     */
    public synchronized void method1() {
        //Синхронизированная логика метода
    }

    /**
     * Аналог метода выше. Блочится по экземпляру вызывающего класса.
     */
    public void method2() {
        synchronized (this) {
            //Синхронизированная логика метода
        }
    }

    /**
     * Синхронизированный статический метод. Блочится по классу.
     * Intrinsic lock пока выполняется метод, остальные синхронизированные статические методы
     * не могут менять статические поля класса.
     */
    public static synchronized void method3() {
        //Синхронизированная логика метода
    }

    /**
     * Аналог метода выше. Блочится по классу.
     */
    public static void method4() {
        synchronized (MainClass.class) {
            //Синхронизированная логика метода
        }
    }
}